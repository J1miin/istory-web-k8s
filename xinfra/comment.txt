여기에 이것저것 개발자가 한 거 다 만들 것
goole k8s엔진도
이 애플리케이션 배포하는 yaml 파일을 다 이 파일에서 관리할 거다.
근데 이 실습에서는 aws eks만 할 것임.
---
1. 디렉토리를 생성해준다. 
mkdir -p aws-eks/base/istory-app
mkdir -p aws-eks/base/istory-db
mkdir -p aws-eks/base/istory-tools
mkdir -p aws-eks/overlay/aws-dev
mkdir -p aws-eks/overlay/aws-prod
mkdir -p aws-eks/overlay/local-dev
: kustomize를 사용한다.
-> 쿠버네티스의 커스터마이즈!
그래서 base가 있거, overlay가 있다.
yaml파일 하나를 정의하고 덮어쓰는게 overlay다.
예전에는 aws용 yaml, 로컬용 yaml을 따로 만들어서 labeling을 해줬다.

기본 문법은 같지만 환경에 따라(클라우드마다, 로컬마다) 조금씩 바뀌고,
원래는 그 환경마다, namespace마다 yaml파일을 따로 따로 만들었었다.
(수정이 매우 불편하고, yaml이 너무 많아진다.)
그래서 똑같은 애플리케이션을 배포하려고 해도, 수정되면, 세 개씩 수정후 배포해야한다.
그래서 kustomize 라이브러리가 있다.

kustomize
: 기본이 되는 yaml 파일을 base에 기록하고,
환경마다 변경되는걸 overlay 폴더에 만들어서
최종 서비스 하는 yaml 파일을 동적으로 만든다.

----
2. 파일 생성하기
xinfra 폴더에서 아래 명령어로 파일 생성
touch aws-eks/base/istory-app/istory-app-config.yml
touch aws-eks/base/istory-app/istory-app-deploy.yml
touch aws-eks/base/istory-app/istory-app-lb.yml
touch aws-eks/base/istory-app/kustomization.yml #많은 kustomizaition 중 내가 뭘 쓸지를 정의해줌
touch aws-eks/base/istory-db/istory-db-pod.yml
touch aws-eks/base/istory-db/istory-db-lb.yml
touch aws-eks/base/istory-db/istory-db-pvc.yml
touch aws-eks/base/istory-db/istory-db-sc.yml
touch aws-eks/base/istory-db-init-config.yml
touch aws-eks/base/istory-db/kustomization.yml #kustomizaition이 뭘 따를지 작성해줌?
touch aws-eks/base/istory-tools/busybox.yml #테스트용도
touch aws-eks/base/istory-tools/kustomization.yml
----여기 위까지는 base yaml이고
----아래는 커스텀해서 덮어쓸 수 있는 yml 파일이다.-----------
touch aws-eks/overlay/aws-dev/kustomization.yml
touch aws-eks/overlay/aws-dev/patch-deploy.yml
touch aws-eks/overlay/aws-dev/patch-lb-annotations.yml
touch aws-eks/overlay/aws-dev/.env.secret

3. 네임스페이스 생성
- 개발용, 운영용 하나 하나 만듦
: istory-dev & istory-prod

4. 도커파일 생성
도커 폴더 > 도커파일 생성

5. 자바 빌드
스프링부트는 gradlew을 써서 빌드한다. (쓰프링은 maven)
./gradlew build -x test -> test 제외하고 빌드한다.

6. istory-app-config 생성

---
현재 파일 구조
/xinfa 
    /docker
    /k8s-platform(new 리포지토리 - 이 때 git submodule 명령어 사용)
    /k8s-infra(new 디렉토리 만들고 이 안에 테라폼 리포지토리 또 만들면 됨)
리파지토리를 분리했다.
소스코드가 바뀌었을 떄의 배프와 (devops)용 yml파일을 변경했다고 배포되면 안되니까
자동배포는 깃이 배포가 되면 발생한다. 
SO, 소스코드만 바뀔 때와, yml만 바뀔 때를 분리하겠다. BY 리포지터리 분리
    -> 소스코드 리포지토리와, YML파일 관리하는 리포지터리, 테라폼 다루는 레포지토리 분리
